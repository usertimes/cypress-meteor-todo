[{"type":"js","data":"//////////////////////////////////////////////////////////////////////////\n//                                                                      //\n// This is a generated file. You can view the original                  //\n// source in your browser if your browser supports source maps.         //\n// Source maps are supported by all recent versions of Chrome, Safari,  //\n// and Firefox, and by Internet Explorer 11.                            //\n//                                                                      //\n//////////////////////////////////////////////////////////////////////////\n\n\n(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar meteorInstall = Package.modules.meteorInstall;\nvar Promise = Package.promise.Promise;\n\n/* Package-scope variables */\nvar Reload;\n\nvar require = meteorInstall({\"node_modules\":{\"meteor\":{\"reload\":{\"reload.js\":function module(require,exports,module){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                             //\n// packages/reload/reload.js                                                                                   //\n//                                                                                                             //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                               //\nmodule.export({\n  Reload: () => Reload\n});\nconst Reload = {};\nconst reloadSettings = Meteor.settings && Meteor.settings.public && Meteor.settings.public.packages && Meteor.settings.public.packages.reload || {};\n\nfunction debug(message, context) {\n  if (!reloadSettings.debug) {\n    return;\n  } // eslint-disable-next-line no-console\n\n\n  console.log(\"[reload] \".concat(message), JSON.stringify(context));\n}\n\nconst KEY_NAME = 'Meteor_Reload';\nlet old_data = {}; // read in old data at startup.\n\nlet old_json; // This logic for sessionStorage detection is based on browserstate/history.js\n\nlet safeSessionStorage = null;\n\ntry {\n  // This throws a SecurityError on Chrome if cookies & localStorage are\n  // explicitly disabled\n  //\n  // On Firefox with dom.storage.enabled set to false, sessionStorage is null\n  //\n  // We can't even do (typeof sessionStorage) on Chrome, it throws.  So we rely\n  // on the throw if sessionStorage == null; the alternative is browser\n  // detection, but this seems better.\n  safeSessionStorage = window.sessionStorage; // Check we can actually use it\n\n  if (safeSessionStorage) {\n    safeSessionStorage.setItem('__dummy__', '1');\n    safeSessionStorage.removeItem('__dummy__');\n  } else {\n    // Be consistently null, for safety\n    safeSessionStorage = null;\n  }\n} catch (e) {\n  // Expected on chrome with strict security, or if sessionStorage not supported\n  safeSessionStorage = null;\n} // Exported for test.\n\n\nReload._getData = function () {\n  return safeSessionStorage && safeSessionStorage.getItem(KEY_NAME);\n};\n\nif (safeSessionStorage) {\n  old_json = Reload._getData();\n  safeSessionStorage.removeItem(KEY_NAME);\n} else {// Unsupported browser (IE 6,7) or locked down security settings.\n  // No session resumption.\n  // Meteor._debug(\"XXX UNSUPPORTED BROWSER/SETTINGS\");\n}\n\nif (!old_json) old_json = '{}';\nlet old_parsed = {};\n\ntry {\n  old_parsed = JSON.parse(old_json);\n\n  if (typeof old_parsed !== 'object') {\n    Meteor._debug('Got bad data on reload. Ignoring.');\n\n    old_parsed = {};\n  }\n} catch (err) {\n  Meteor._debug('Got invalid JSON on reload. Ignoring.');\n}\n\nif (old_parsed.reload && typeof old_parsed.data === 'object') {\n  // Meteor._debug(\"Restoring reload data.\");\n  old_data = old_parsed.data;\n}\n\nlet providers = []; ////////// External API //////////\n// Packages that support migration should register themselves by calling\n// this function. When it's time to migrate, callback will be called\n// with one argument, the \"retry function,\" and an optional 'option'\n// argument (containing a key 'immediateMigration'). If the package\n// is ready to migrate, it should return [true, data], where data is\n// its migration data, an arbitrary JSON value (or [true] if it has\n// no migration data this time). If the package needs more time\n// before it is ready to migrate, it should return false. Then, once\n// it is ready to migrating again, it should call the retry\n// function. The retry function will return immediately, but will\n// schedule the migration to be retried, meaning that every package\n// will be polled once again for its migration data. If they are all\n// ready this time, then the migration will happen. name must be set if there\n// is migration data. If 'immediateMigration' is set in the options\n// argument, then it doesn't matter whether the package is ready to\n// migrate or not; the reload will happen immediately without waiting\n// (used for OAuth redirect login).\n//\n\nReload._onMigrate = function (name, callback) {\n  debug('_onMigrate', {\n    name\n  });\n\n  if (!callback) {\n    // name not provided, so first arg is callback.\n    callback = name;\n    name = undefined;\n    debug('_onMigrate no callback');\n  }\n\n  providers.push({\n    name: name,\n    callback: callback\n  });\n}; // Called by packages when they start up.\n// Returns the object that was saved, or undefined if none saved.\n//\n\n\nReload._migrationData = function (name) {\n  debug('_migrationData', {\n    name\n  });\n  return old_data[name];\n}; // Options are the same as for `Reload._migrate`.\n\n\nconst pollProviders = function (tryReload, options) {\n  debug('pollProviders', {\n    options\n  });\n\n  tryReload = tryReload || function () {};\n\n  options = options || {};\n  const {\n    immediateMigration\n  } = options;\n  debug(\"pollProviders is \".concat(immediateMigration ? '' : 'NOT ', \"immediateMigration\"), {\n    options\n  });\n  const migrationData = {};\n  let allReady = true;\n  providers.forEach(p => {\n    const {\n      callback,\n      name\n    } = p || {};\n    const [ready, data] = callback(tryReload, options) || [];\n    debug(\"pollProviders provider \".concat(name || 'unknown', \" is \").concat(ready ? 'ready' : 'NOT ready'), {\n      options\n    });\n\n    if (!ready) {\n      allReady = false;\n    }\n\n    if (data !== undefined && name) {\n      migrationData[name] = data;\n    }\n  });\n\n  if (allReady) {\n    debug('pollProviders allReady', {\n      options,\n      migrationData\n    });\n    return migrationData;\n  }\n\n  if (immediateMigration) {\n    debug('pollProviders immediateMigration', {\n      options,\n      migrationData\n    });\n    return migrationData;\n  }\n\n  return null;\n}; // Options are:\n//  - immediateMigration: true if the page will be reloaded immediately\n//    regardless of whether packages report that they are ready or not.\n\n\nReload._migrate = function (tryReload, options) {\n  debug('_migrate', {\n    options\n  }); // Make sure each package is ready to go, and collect their\n  // migration data\n\n  const migrationData = pollProviders(tryReload, options);\n\n  if (migrationData === null) {\n    return false; // not ready yet..\n  }\n\n  let json;\n\n  try {\n    // Persist the migration data\n    json = JSON.stringify({\n      data: migrationData,\n      reload: true\n    });\n  } catch (err) {\n    Meteor._debug(\"Couldn't serialize data for migration\", migrationData);\n\n    throw err;\n  }\n\n  if (safeSessionStorage) {\n    try {\n      safeSessionStorage.setItem(KEY_NAME, json);\n    } catch (err) {\n      // We should have already checked this, but just log - don't throw\n      Meteor._debug(\"Couldn't save data for migration to sessionStorage\", err);\n    }\n  } else {\n    Meteor._debug('Browser does not support sessionStorage. Not saving migration state.');\n  }\n\n  return true;\n}; // Allows tests to isolate the list of providers.\n\n\nReload._withFreshProvidersForTest = function (f) {\n  const originalProviders = providers.slice(0);\n  providers = [];\n\n  try {\n    f();\n  } finally {\n    providers = originalProviders;\n  }\n}; // Migrating reload: reload this page (presumably to pick up a new\n// version of the code or assets), but save the program state and\n// migrate it over. This function returns immediately. The reload\n// will happen at some point in the future once all of the packages\n// are ready to migrate.\n//\n\n\nlet reloading = false;\n\nReload._reload = function (options) {\n  debug('_reload', {\n    options\n  });\n  options = options || {};\n\n  if (reloading) {\n    debug('reloading in progress already', {\n      options\n    });\n    return;\n  }\n\n  reloading = true;\n\n  function tryReload() {\n    debug('tryReload');\n    setTimeout(reload, 1);\n  }\n\n  function forceBrowserReload() {\n    debug('forceBrowserReload'); // We'd like to make the browser reload the page using location.replace()\n    // instead of location.reload(), because this avoids validating assets\n    // with the server if we still have a valid cached copy. This doesn't work\n    // when the location contains a hash however, because that wouldn't reload\n    // the page and just scroll to the hash location instead.\n\n    if (window.location.hash || window.location.href.endsWith('#')) {\n      window.location.reload();\n      return;\n    }\n\n    window.location.replace(window.location.href);\n  }\n\n  function reload() {\n    debug('reload');\n\n    if (!Reload._migrate(tryReload, options)) {\n      return;\n    }\n\n    if (Meteor.isCordova) {\n      WebAppLocalServer.switchToPendingVersion(() => {\n        forceBrowserReload();\n      });\n      return;\n    }\n\n    forceBrowserReload();\n  }\n\n  tryReload();\n};\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}}}}},{\n  \"extensions\": [\n    \".js\",\n    \".json\"\n  ]\n});\n\nvar exports = require(\"/node_modules/meteor/reload/reload.js\");\n\n/* Exports */\nPackage._define(\"reload\", exports, {\n  Reload: Reload\n});\n\n})();\n","servePath":"/packages/reload.js","sourceMap":{"version":3,"sources":["packages/reload/reload.js"],"names":["module","export","Reload","reloadSettings","Meteor","settings","public","packages","reload","debug","message","context","console","log","JSON","stringify","KEY_NAME","old_data","old_json","safeSessionStorage","window","sessionStorage","setItem","removeItem","e","_getData","getItem","old_parsed","parse","_debug","err","data","providers","_onMigrate","name","callback","undefined","push","_migrationData","pollProviders","tryReload","options","immediateMigration","migrationData","allReady","forEach","p","ready","_migrate","json","_withFreshProvidersForTest","f","originalProviders","slice","reloading","_reload","setTimeout","forceBrowserReload","location","hash","href","endsWith","replace","isCordova","WebAppLocalServer","switchToPendingVersion"],"mappings":"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","file":"/packages/reload.js","sourcesContent":["/**\n * This code does _NOT_ support hot (session-restoring) reloads on\n * IE6,7. It only works on browsers with sessionStorage support.\n *\n * There are a couple approaches to add IE6,7 support:\n *\n * - use IE's \"userData\" mechanism in combination with window.name.\n * This mostly works, however the problem is that it can not get to the\n * data until after DOMReady. This is a problem for us since this API\n * relies on the data being ready before API users run. We could\n * refactor using Meteor.startup in all API users, but that might slow\n * page loads as we couldn't start the stream until after DOMReady.\n * Here are some resources on this approach:\n * https://github.com/hugeinc/USTORE.js\n * http://thudjs.tumblr.com/post/419577524/localstorage-userdata\n * http://www.javascriptkit.com/javatutors/domstorage2.shtml\n *\n * - POST the data to the server, and have the server send it back on\n * page load. This is nice because it sidesteps all the local storage\n * compatibility issues, however it is kinda tricky. We can use a unique\n * token in the URL, then get rid of it with HTML5 pushstate, but that\n * only works on pushstate browsers.\n *\n * This will all need to be reworked entirely when we add server-side\n * HTML rendering. In that case, the server will need to have access to\n * the client's session to render properly.\n */\n\n// XXX when making this API public, also expose a flag for the app\n// developer to know whether a hot code push is happening. This is\n// useful for apps using `window.onbeforeunload`. See\n// https://github.com/meteor/meteor/pull/657\n\nexport const Reload = {};\n\nconst reloadSettings =\n  (Meteor.settings &&\n    Meteor.settings.public &&\n    Meteor.settings.public.packages &&\n    Meteor.settings.public.packages.reload) ||\n  {};\n\nfunction debug(message, context) {\n  if (!reloadSettings.debug) {\n    return;\n  }\n  // eslint-disable-next-line no-console\n  console.log(`[reload] ${message}`, JSON.stringify(context));\n}\n\nconst KEY_NAME = 'Meteor_Reload';\n\nlet old_data = {};\n// read in old data at startup.\nlet old_json;\n\n// This logic for sessionStorage detection is based on browserstate/history.js\nlet safeSessionStorage = null;\ntry {\n  // This throws a SecurityError on Chrome if cookies & localStorage are\n  // explicitly disabled\n  //\n  // On Firefox with dom.storage.enabled set to false, sessionStorage is null\n  //\n  // We can't even do (typeof sessionStorage) on Chrome, it throws.  So we rely\n  // on the throw if sessionStorage == null; the alternative is browser\n  // detection, but this seems better.\n  safeSessionStorage = window.sessionStorage;\n\n  // Check we can actually use it\n  if (safeSessionStorage) {\n    safeSessionStorage.setItem('__dummy__', '1');\n    safeSessionStorage.removeItem('__dummy__');\n  } else {\n    // Be consistently null, for safety\n    safeSessionStorage = null;\n  }\n} catch (e) {\n  // Expected on chrome with strict security, or if sessionStorage not supported\n  safeSessionStorage = null;\n}\n\n// Exported for test.\nReload._getData = function () {\n  return safeSessionStorage && safeSessionStorage.getItem(KEY_NAME);\n};\n\nif (safeSessionStorage) {\n  old_json = Reload._getData();\n  safeSessionStorage.removeItem(KEY_NAME);\n} else {\n  // Unsupported browser (IE 6,7) or locked down security settings.\n  // No session resumption.\n  // Meteor._debug(\"XXX UNSUPPORTED BROWSER/SETTINGS\");\n}\n\nif (!old_json) old_json = '{}';\nlet old_parsed = {};\ntry {\n  old_parsed = JSON.parse(old_json);\n  if (typeof old_parsed !== 'object') {\n    Meteor._debug('Got bad data on reload. Ignoring.');\n    old_parsed = {};\n  }\n} catch (err) {\n  Meteor._debug('Got invalid JSON on reload. Ignoring.');\n}\n\nif (old_parsed.reload && typeof old_parsed.data === 'object') {\n  // Meteor._debug(\"Restoring reload data.\");\n  old_data = old_parsed.data;\n}\n\nlet providers = [];\n\n////////// External API //////////\n\n// Packages that support migration should register themselves by calling\n// this function. When it's time to migrate, callback will be called\n// with one argument, the \"retry function,\" and an optional 'option'\n// argument (containing a key 'immediateMigration'). If the package\n// is ready to migrate, it should return [true, data], where data is\n// its migration data, an arbitrary JSON value (or [true] if it has\n// no migration data this time). If the package needs more time\n// before it is ready to migrate, it should return false. Then, once\n// it is ready to migrating again, it should call the retry\n// function. The retry function will return immediately, but will\n// schedule the migration to be retried, meaning that every package\n// will be polled once again for its migration data. If they are all\n// ready this time, then the migration will happen. name must be set if there\n// is migration data. If 'immediateMigration' is set in the options\n// argument, then it doesn't matter whether the package is ready to\n// migrate or not; the reload will happen immediately without waiting\n// (used for OAuth redirect login).\n//\nReload._onMigrate = function (name, callback) {\n  debug('_onMigrate', {name});\n  if (!callback) {\n    // name not provided, so first arg is callback.\n    callback = name;\n    name = undefined;\n    debug('_onMigrate no callback');\n  }\n\n  providers.push({name: name, callback: callback});\n};\n\n// Called by packages when they start up.\n// Returns the object that was saved, or undefined if none saved.\n//\nReload._migrationData = function (name) {\n  debug('_migrationData', {name});\n  return old_data[name];\n};\n\n// Options are the same as for `Reload._migrate`.\nconst pollProviders = function (tryReload, options) {\n  debug('pollProviders', {options});\n  tryReload = tryReload || function () {\n  };\n  options = options || {};\n\n  const {immediateMigration} = options;\n  debug(\n    `pollProviders is ${immediateMigration ? '' : 'NOT '}immediateMigration`,\n    {options}\n  );\n  const migrationData = {};\n  let allReady = true;\n  providers.forEach(p => {\n    const {callback, name} = p || {};\n    const [ready, data] = callback(tryReload, options) || [];\n\n    debug(\n      `pollProviders provider ${name || 'unknown'} is ${\n        ready ? 'ready' : 'NOT ready'\n      }`,\n      {options}\n    );\n    if (!ready) {\n      allReady = false;\n    }\n\n    if (data !== undefined && name) {\n      migrationData[name] = data;\n    }\n  });\n\n  if (allReady) {\n    debug('pollProviders allReady', {options, migrationData});\n    return migrationData;\n  }\n\n  if (immediateMigration) {\n    debug('pollProviders immediateMigration', {options, migrationData});\n    return migrationData;\n  }\n\n  return null;\n};\n\n// Options are:\n//  - immediateMigration: true if the page will be reloaded immediately\n//    regardless of whether packages report that they are ready or not.\nReload._migrate = function (tryReload, options) {\n  debug('_migrate', {options});\n  // Make sure each package is ready to go, and collect their\n  // migration data\n  const migrationData = pollProviders(tryReload, options);\n  if (migrationData === null) {\n    return false; // not ready yet..\n  }\n\n  let json;\n  try {\n    // Persist the migration data\n    json = JSON.stringify({\n      data: migrationData,\n      reload: true,\n    });\n  } catch (err) {\n    Meteor._debug(\"Couldn't serialize data for migration\", migrationData);\n    throw err;\n  }\n\n  if (safeSessionStorage) {\n    try {\n      safeSessionStorage.setItem(KEY_NAME, json);\n    } catch (err) {\n      // We should have already checked this, but just log - don't throw\n      Meteor._debug(\"Couldn't save data for migration to sessionStorage\", err);\n    }\n  } else {\n    Meteor._debug(\n      'Browser does not support sessionStorage. Not saving migration state.'\n    );\n  }\n\n  return true;\n};\n\n// Allows tests to isolate the list of providers.\nReload._withFreshProvidersForTest = function (f) {\n  const originalProviders = providers.slice(0);\n  providers = [];\n  try {\n    f();\n  } finally {\n    providers = originalProviders;\n  }\n};\n\n// Migrating reload: reload this page (presumably to pick up a new\n// version of the code or assets), but save the program state and\n// migrate it over. This function returns immediately. The reload\n// will happen at some point in the future once all of the packages\n// are ready to migrate.\n//\nlet reloading = false;\nReload._reload = function (options) {\n  debug('_reload', {options});\n  options = options || {};\n\n  if (reloading) {\n    debug('reloading in progress already', {options});\n    return;\n  }\n  reloading = true;\n\n  function tryReload() {\n    debug('tryReload');\n    setTimeout(reload, 1);\n  }\n\n  function forceBrowserReload() {\n    debug('forceBrowserReload');\n    // We'd like to make the browser reload the page using location.replace()\n    // instead of location.reload(), because this avoids validating assets\n    // with the server if we still have a valid cached copy. This doesn't work\n    // when the location contains a hash however, because that wouldn't reload\n    // the page and just scroll to the hash location instead.\n    if (window.location.hash || window.location.href.endsWith('#')) {\n      window.location.reload();\n      return;\n    }\n\n    window.location.replace(window.location.href);\n  }\n\n  function reload() {\n    debug('reload');\n    if (!Reload._migrate(tryReload, options)) {\n      return;\n    }\n\n    if (Meteor.isCordova) {\n      WebAppLocalServer.switchToPendingVersion(() => {\n        forceBrowserReload();\n      });\n      return;\n    }\n\n    forceBrowserReload();\n  }\n\n  tryReload();\n};\n"]}}]